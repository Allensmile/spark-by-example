#+EXPORT_FILE_NAME: ../../../sorting/Partial_Sort.org
#+OPTIONS: author:nil title:nil toc:nil

** The Partial_Sort algorithm

   The ~Partial_Sort~ algorithm sorts one part of an array and
   ensures that every element at the left is less than every element
   at the right. Its signature is:

   #+BEGIN_SRC ada
     procedure Partial_Sort (A : in out T_Arr; M : Positive)
   #+END_SRC

   This algorithm uses a lot of previously proved algorithms and
   previously used techniques to help the provers.

*** The Partition predicate

    The ~Partition~ predicate is the following:

    #+INCLUDE: "../../../spec/partition_p.ads" :src ada :range-begin "function Partition" :range-end "\s-*(\([^()]*?\(?:\n[^()]*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "8-15"

*** Specification of Partial_Sort

    The specification of ~Partial_Sort~ is rather simple:

    #+INCLUDE: "../../../sorting/partial_sort_p.ads" :src ada :range-begin "procedure Partial_Sort[^_]" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "38-44"

    The length of ~A~ has to be less than the maximum size of a heap
    because a heap will be used in the implementation.

*** The Partial_Sort_Aux procedure

    This function is used in our implementation and apply the
    algorithm on a ~Heap~ data structure representing a heap between
    indexes ~1~ and ~M-1~ instead of an array ~A~.

**** Specification of Partial_Sort_Aux

     The specification of our auxiliary function is:

     #+INCLUDE: "../../../sorting/partial_sort_p.ads" :src ada :range-begin "procedure Partial_Sort_Aux" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "27-37"

     This function will only be called if ~M > A'First~, that is why
     ~M~ is in range ~2 .. H.Size~. At the end of the function, the
     ~Size~ attribute and the rest of the encapsulated array have not
     changed.

**** Implementation of Partial_Sort_Aux

     The implementation of ~Partial_Sort_Aux~ is the following:

     #+INCLUDE: "../../../sorting/partial_sort_p.adb" :src ada :range-begin "procedure Partial_Sort_Aux" :range-end "End Partial_Sort_Aux;" :lines "15-51"

     The ~Size~ constant is equal to the size of the encapsulated
     array that is a heap. ~Old_Size~ is equal to the size of the
     ~Heap~ ~H~, which will be equal to the length of the array used
     in ~Partial_Sort~. At each iteration, the first element of the
     encapsulated array is (of course) the greatest in the heap (we
     use the same lemma as in [[../heap/Pop_Heap.org][Pop_Heap]], ~Upper_Bound_Heap~), and is
     less than every element encountered between ~M~ and ~J~. If the
     ~J + 1~ th element is less than the first, we pop the heap, swap
     the first element which is now at index ~M - 1~ with the ~J + 1~
     th and then we push the heap. The ~Prove_Lower_Bound~ lemma is
     used to prove the loop invariant with
     ~Lower_Bound~. ~Prove_Partition~ will help proving that after
     sorting the heap, the array remains a partition.

*** The lemmas
**** New classic lemmas

     We need to write some useful lemmas first.

     The first lemma proves that if ~Occ (A, V)~ is greater or equal
     to ~1~, then ~Has_Value (A, V)~ is true. The specification of
     ~Occ_To_Has_Value~ is:

     #+INCLUDE: "../../../lemmas/classic_lemmas.ads" :src ada :range-begin "procedure Occ_To_Has_Value" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "54-59"

     Is implementation is:

     #+INCLUDE: "../../../lemmas/classic_lemmas.adb" :src ada :range-begin "procedure Occ_To_Has_Value" :range-end "End Occ_To_Has_Value;" :lines "58-73"

     We have also implemented the other way of the equivalence as a
     lemma: if ~Has_Value (A, V)~ is true, then ~Occ (A, V)~ is
     greater or equal to ~1~.

     #+INCLUDE: "../../../lemmas/classic_lemmas.ads" :src ada :range-begin "procedure Has_Value_To_Occ" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "60-65"

     #+INCLUDE: "../../../lemmas/classic_lemmas.adb" :src ada :range-begin "procedure Has_Value_To_Occ" :range-end "End Has_Value_To_Occ;" :lines "74-92"

     For further details about the two implementations, we already
     explained it in detail when proving functions such as [[../mutating/Remove_Copy.org][Remove_Copy]]
     or [[../mutating/Random_Shuffle.org][Random_Shuffle]].

     We also need a lemma to prove a property about
     ~Multiset_Unchanged~. When ~Multiset_Unchanged (A, B)~ is
     verified and ~A (Eq .. A'Last) = B (Eq - A'First + B'First
     .. B'Last)~ for a valid index ~Eq~, then ~Multiset_Unchanged(A
     (A'First .. Eq - 1), B (B'First .. Eq - A'First + B'First - 1))~
     holds.

     The specification of ~Partial_Eq~ is:

     #+INCLUDE: "../../../lemmas/classic_lemmas.ads" :src ada :range-begin "procedure Partial_Eq" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "66-76"

     The implementation is:

     #+INCLUDE: "../../../lemmas/classic_lemmas.adb" :src ada :range-begin "procedure Partial_Eq" :range-end "End Partial_Eq;" :lines "93-111"

     The implementation may seem very difficult but we just adapt the
     lemma for the cases where ~A~ and ~B~ does not have the same
     first index, to allow the user to use it outside of our function.

**** The Prove_Lower_Bound lemma

     This lemma helps proving the ~Lower_Bound~ loop invariant.
     Before calling ~Push_Heap (H)~ in ~Partial_Sort_Aux~, the
     assertion ~Lower_Bound (H.A (M .. J), H.A (K))~ for all ~K in 1
     .. M - 1~ is proved. After the command, it is not proved any
     more. We need to make a backup of ~H.A~ before pushing the heap,
     and then use this lemma.

     The specification of the lemma is:

     #+INCLUDE: "../../../lemmas/partial_sort_lemmas.ads" :src ada :range-begin "procedure Prove_Lower_Bound" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "16-29"

     The method used is to implement it is the following:
     - we suppose ~Multiset_Unchanged (A, A_Save)~ and ~for all K in M
       .. MAX_SIZE => A (K) = A_Save (K)~, then we have
       ~Multiset_Unchanged(A (1 .. Eq - 1), A_Save (1 .. Eq - 1))~.
     - ~Has_Value (A (1 .. Eq - 1), A (1))~ is true, therefore ~Occ(A
       (1 .. Eq - 1),A(1)) >= 1~.
     - ~Multiset_Unchanged(A (1 .. Eq - 1), A_Save (1 .. Eq - 1))~ is
       true therefore ~Occ(A (1 .. Eq - 1),A(1)) = Occ(A_Save (1
       .. Eq - 1),A(1))~ then ~Occ(A_Save(1 .. Eq - 1), A(1)) >= 1~.
     - ~Occ(A_Save(1 .. Eq - 1), A(1)) >= 1~ thus ~Has_Value(A_Save (1
       .. Eq - 1),A(1))~.
     - ~for all K in 1 .. M - 1 => Lower_Bound (A_Save (M .. J),
       A_Save (K))~ then for the specific index where ~A(1)~ is, it is
       also true too.

       This implementation of this lemma is:

       #+INCLUDE: "../../../lemmas/partial_sort_lemmas.adb" :src ada :range-begin "procedure Prove_Lower_Bound" :range-end "End Prove_Lower_Bound;" :lines "6-16"

**** The Prove_Partition lemma

     This lemma helps proving that the array with the ~Partition~
     property on the ~M~ th value will keep verifying the property if
     we sort it before ~M~.  The specification is:

     #+INCLUDE: "../../../lemmas/partial_sort_lemmas.ads" :src ada :range-begin "procedure Prove_Partition" :range-end "\s-*(\(.*?\(?:\n.*\)*?\)*)\s-*\([^;]*?\(?:\n[^;]*\)*?\)*;" :lines "30-41"

     The implementation is similar to the previous one, except for the
     fact that we want to prove the ~Partition~ predicate for all ~K~
     in a certain range. The implementation is the following:

     #+INCLUDE: "../../../lemmas/partial_sort_lemmas.adb" :src ada :range-begin "procedure Prove_Partition" :range-end "End Prove_Partition;" :lines "17-31"

     Using ~GNATprove~, the lemmas and their implementations are
     proved.

*** Implementation of ~Partial_Sort~

    The point here is to prepare a ~Heap~ to apply our auxiliary
    function on it. We first make a heap with the ~M - 1~ first
    elements, and we add the following elements one by one, preserving
    the ~Multiset_Unchanged~ predicate using the ~New_Element~ lemma
    described in [[../heap/Make_Heap.org][Make_Heap]]. We apply the auxiliary function to our
    heap. The only thing remaining is playing with a backup of ~A~ to
    prove the ~Multiset_Unchanged~ preservation.

    #+INCLUDE: "../../../sorting/partial_sort_p.adb" :src ada :range-begin "procedure Partial_Sort[^_]" :range-end "End Partial_Sort;" :lines "52-99"

    Using this implementation and specification, ~GNATprove~ proves
    the ~Partial_Sort~ algorithm.

# Local Variables:
# ispell-dictionary: "english"
# End:
